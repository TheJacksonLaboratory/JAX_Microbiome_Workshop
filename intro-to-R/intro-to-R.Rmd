---
title: "Introduction to R"
Instructor: "Sandeep Namburi"
date: "10/27/2020"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    collapsed: true
    smooth_scroll: true
    code_folding: show
---

&copy; Software Carpentry Foundation.
This material adapted from Software Carpentry's "Introduction to R for non-programmers using gapminder data" lesson:
Thomas Wright and Naupaka Zimmerman (eds): "Software Carpentry: R for
Reproducible Scientific Analysis."  Version 2016.06, June 2016,
https://github.com/swcarpentry/r-novice-gapminder,
10.5281/zenodo.57520.

# Basic R
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Before Starting The Workshop

Please ensure you have the latest version of R and RStudio installed on your machine. This is important, as some packages used in the workshop may not install correctly (or at all) if R is not up to date.

* [Download and install the latest version of R here](https://www.r-project.org/)

* [Download and install RStudio here](https://www.rstudio.com/)

## Introduction to RStudio

Welcome to the R portion of the workshop.

Throughout this lesson, we're going to teach you some of the fundamentals of
the R language as well as some best practices for organizing code for
scientific projects that will make your life easier.

We'll be using RStudio: a free, open source R integrated development
environment. It provides a built in editor, works on all platforms (including
on servers) and provides many advantages such as integration with version
control and project management.



**Basic layout**

When you first open RStudio, you will be greeted by three panels:

  * The interactive R console (entire left)
  * Environment/History (tabbed in upper right)
  * Files/Plots/Packages/Help/Viewer (tabbed in lower right)

![RStudio layout](./fig/01-rstudio.png)

Once you open files, such as R scripts, an editor panel will also open
in the top left.

![RStudio layout with .R file open](./fig/01-rstudio-script.png)


## Workflow within RStudio
There are two main ways one can work within RStudio.

1. Test and play within the interactive R console then copy code into
a .R file to run later.
   *  This works well when doing small tests and initially starting off.
   *  It quickly becomes laborious
2. Start writing in an .R file and use RStudio's short cut keys for the Run command
to push the current line, selected lines or modified lines to the
interactive R console.
   * This is a great way to start; all your code is saved for later
   * You will be able to run the file you create from within RStudio
   or using R's `source()`  function.

> ### Tip: Running segments of your code
>
> RStudio offers you great flexibility in running code from within the editor
> window. There are buttons, menu choices, and keyboard shortcuts. To run the
> current line, you can 
> 1. click on the `Run` button above the editor panel, or 
> 2. select "Run Lines" from the "Code" menu, or 
> 3. hit <kbd>Ctrl</kbd>+<kbd>Return</kbd> in Windows or Linux 
> or <kbd>&#8984;</kbd>+<kbd>Return</kbd> on OS X.
> (This shortcut can also be seen by hovering
> the mouse over the button). To run a block of code, select it and then `Run`.
> If you have modified a line of code within a block of code you have just run,
> there is no need to reselect the section and `Run`, you can use the next button
> along, `Re-run the previous region`. This will run the previous code block
> including the modifications you have made.


## Introduction to R

Much of your time in R will be spent in the R interactive
console. This is where you will run all of your code, and can be a
useful environment to try out ideas before adding them to an R script
file. This console in RStudio is the same as the one you would get if
you typed in `R` in your command-line environment.

The first thing you will see in the R interactive session is a bunch
of information, followed by a ">" and a blinking cursor. In many ways
this is similar to the shell environment you learned about during the
shell lessons: it operates on the same idea of a "Read, evaluate,
print loop": you type in commands, R tries to execute them, and then
returns a result.

## Using R as a calculator

The simplest thing you could do with R is do arithmetic:

```{r}
1 + 100
```

And R will print out the answer, with a preceding "[1]". Don't worry about this
for now, we'll explain that later. For now think of it as indicating output.

Like bash, if you type in an incomplete command, R will wait for you to
complete it:

~~~
> 1 +
~~~


~~~
+
~~~


Any time you hit return and the R session shows a "+" instead of a ">", it
means it's waiting for you to complete the command. If you want to cancel
a command you can simply hit "Esc" and RStudio will give you back the ">"
prompt.

> ### Tip: Cancelling commands
>
> If you're using R from the commandline instead of from within RStudio,
> you need to use <kbd>Ctrl</kbd>+<kbd>C</kbd> instead of <kbd>Esc</kbd>
> to cancel the command. This applies to Mac users as well!
>
> Cancelling a command isn't only useful for killing incomplete commands:
> you can also use it to tell R to stop running code (for example if it's
> taking much longer than you expect), or to get rid of the code you're
> currently writing.
>


When using R as a calculator, the order of operations is the same as you
would have learned back in school.

From highest to lowest precedence:

 * Parentheses: `(`, `)`
 * Exponents: `^` or `**`
 * Divide: `/`
 * Multiply: `*`
 * Add: `+`
 * Subtract: `-`

```{r}
3 + 5 * 2
```

Use parentheses to group operations in order to force the order of
evaluation if it differs from the default, or to make clear what you
intend.

```{r}
(3 + 5) * 2
```

This can get unwieldy when not needed, but  clarifies your intentions.
Remember that others may later read your code.

```{r, eval=FALSE}
(3 + (5 * (2 ^ 2))) # hard to read
3 + 5 * 2 ^ 2       # clear, if you remember the rules
3 + 5 * (2 ^ 2)     # if you forget some rules, this might help
```


The text after each line of code is called a
"comment". Anything that follows after the hash (or octothorpe) symbol
`#` is ignored by R when it executes code.

Really small or large numbers get a scientific notation:

```{r}
2/10000
```

Which is shorthand for "multiplied by `10^XX`". So `2e-4`
is shorthand for `2 * 10^(-4)`.

You can write numbers in scientific notation too:

```{r}
5e3  # Note the lack of minus here
```

## Mathematical functions

R has many built in mathematical functions. To call a function,
we simply type its name, followed by  open and closing parentheses.
Anything we type inside the parentheses is called the function's
arguments:

```{r}
sin(1)  # trigonometry functions
```

```{r}
log(1)  # natural logarithm
```

```{r}
log10(10) # base-10 logarithm
```

```{r}
exp(0.5) # e^(1/2)
```

Don't worry about trying to remember every function in R. You
can simply look them up on Google, or if you can remember the
start of the function's name, use the tab completion in RStudio.

This is one advantage that RStudio has over R on its own, it
has auto-completion abilities that allow you to more easily
look up functions, their arguments, and the values that they
take.

Typing a `?` before the name of a command will open the help page
for that command. As well as providing a detailed description of
the command and how it works, scrolling to the bottom of the
help page will usually show a collection of code examples which
illustrate command usage. We'll go through an example later.

## Comparing things

We can also do comparison in R:

```{r}
1 == 1  # equality (note two equals signs, read as "is equal to")
```

```{r}
1 != 2  # inequality (read as "is not equal to")
```

```{r}
1 < 2  # less than
```

```{r}
1 <= 1  # less than or equal to
```

```{r}
1 > 0  # greater than
```

```{r}
1 >= -9 # greater than or equal to
```

> ### Tip: Comparing Numbers
>
> A word of warning about comparing numbers: you should
> never use `==` to compare two numbers unless they are
> integers (a data type which can specifically represent
> only whole numbers).
>
> Computers may only represent decimal numbers with a
> certain degree of precision, so two numbers which look
> the same when printed out by R, may actually have
> different underlying representations and therefore be
> different by a small margin of error (called Machine
> numeric tolerance).
>
> Instead you should use the `all.equal` function.
>
> Further reading: [http://floating-point-gui.de/](http://floating-point-gui.de/)
>


## Variables and assignment

We can store values in variables using the assignment operator `<-`, like this:

```{r}
x <- 1/40
```

Notice that assignment does not print a value. Instead, we stored it for later
in something called a **variable**. `x` now contains the **value** `0.025`:

```{r}
x
```

More precisely, the stored value is a *decimal approximation* of
this fraction called a [floating point number](http://en.wikipedia.org/wiki/Floating_point).

Look for the `Environment` tab in one of the panes of RStudio, and you will see that `x` and its value
have appeared. Our variable `x` can be used in place of a number in any calculation that expects a number:

```{r}
log(x)
```

Notice also that variables can be reassigned:

```{r}
x <- 100
```

`x` used to contain the value 0.025 and and now it has the value 100.

Assignment values can contain the variable being assigned to:

```{r}
x <- x + 1 #notice how RStudio updates its description of x on the top right tab
y <- x * 2
```

The right hand side of the assignment can be any valid R expression.
The right hand side is *fully evaluated* before the assignment occurs.

Variable names can contain letters, numbers, underscores and periods. They
cannot start with a number nor contain spaces at all. Different people use
different conventions for long variable names, these include

  * periods.between.words
  * underscores\_between_words
  * camelCaseToSeparateWords

What you use is up to you, but **be consistent**.

It is also possible to use the `=` operator for assignment:

```{r}
x = 1/40
```

But this is much less common among R users.  The most important thing is to
**be consistent** with the operator you use. There are occasionally places
where it is less confusing to use `<-` than `=`, and it is the most common
symbol used in the community. So the recommendation is to use `<-`.


> ### Challenge 1
> 
>  Which of the following are valid R variable names?
> 
> ```{r, eval=FALSE}
>  min_height
>  max.height
>  _age
>  .mass
>  MaxLength
>  min-length
>  2widths
>  celsius2kelvin
> ```
>
>  > #### Solution to challenge 1
>  > 
>  > The following can be used as R variables:
>  > ```{r ch1pt1-sol, eval=FALSE, class.source = 'fold-hide'}
>  > min_height
>  > max.height
>  > MaxLength
>  > celsius2kelvin
>  > ```
>  > 
>  > The following creates a hidden variable:
>  > ```{r ch1pt2-sol, eval=FALSE, class.source = 'fold-hide'}
>  > .mass
>  > ```
>  > 
>  > The following will not be able to be used to create a variable
>  > ```{r ch1pt3-sol, eval=FALSE, class.source = 'fold-hide'}
>  > _age
>  > min-length
>  > 2widths
>  > ```



## Vectorization

One final thing to be aware of is that R is *vectorized*, meaning that
variables and functions can have vectors as values. In contrast to physics and
mathematics, a vector in R describes a set of values in a certain order of the 
same data type. For example

```{r}
1:5
2^(1:5)
x <- 1:5
2^x
```

This is incredibly powerful; we will discuss this further in an
upcoming lesson.


## Managing your environment

There are a few useful commands you can use to interact with the R session.

`ls` will list all of the variables and functions stored in the global environment
(your working R session):

```{r}
ls()
```

> ### Tip: hidden objects
>
> Like in the shell, `ls` will hide any variables or functions starting
> with a "." by default. To list all objects, type `ls(all.names=TRUE)`
> instead
>

Note here that we didn't give any arguments to `ls`, but we still
needed to give the parentheses to tell R to call the function.

If we type `ls` by itself, R will print out the source code for that function!

```{r}
ls
```

You can use `rm` to delete objects you no longer need:

```{r, eval=FALSE}
rm(x)
```

If you have lots of things in your environment and want to delete all of them,
you can pass the results of `ls` to the `rm` function:

```{r, eval=FALSE}
rm(list = ls())
```

In this case we've combined the two. Like the order of operations, anything
inside the innermost parentheses is evaluated first, and so on.

In this case we've specified that the results of `ls` should be used for the
`list` argument in `rm`. When assigning values to arguments by name, you *must*
use the `=` operator!!

If instead we use `<-`, there will be unintended side effects, or you may get an error message:

```{r, error=TRUE}
rm(list <- ls())
```

> ### Tip: Warnings vs. Errors
>
> Pay attention when R does something unexpected! Errors, like above,
> are thrown when R cannot proceed with a calculation. Warnings on the
> other hand usually mean that the function has run, but it probably
> hasn't worked as expected.
>
> In both cases, the message that R prints out usually give you clues
> how to fix a problem.
>


## R Packages

It is possible to add functions to R by writing a package, or by
obtaining a package written by someone else. As of this writing, there
are over 10,000 packages available on CRAN (the comprehensive R archive
network). R and RStudio have functionality for managing packages:

* You can see what packages are installed by typing
  `installed.packages()`
* You can install packages by typing `install.packages("packagename")`,
  where `packagename` is the package name, in quotes.
* You can update installed packages by typing `update.packages()`
* You can remove a package with `remove.packages("packagename")`
* You can make a package available for use with `library(packagename)`

> ### Challenge 2
>
> What will be the value of each  variable  after each
> statement in the following program?
>
> ```{r, eval=FALSE}
> mass <- 47.5
> age <- 122
> mass <- mass * 2.3
> age <- age - 20
> ```
>
> > #### Solution to challenge 2
> >
> > ```{r ch2pt1-sol, class.source = 'fold-hide'}
> > mass <- 47.5
> > ```
> > This will give a value of `r mass` for the variable mass
> >
> > ```{r ch2pt2-sol, class.source = 'fold-hide'}
> > age <- 122
> > ```
> > This will give a value of `r age` for the variable age
> >
> > ```{r ch2pt3-sol, class.source = 'fold-hide'}
> > mass <- mass * 2.3
> > ```
> > This will multiply the existing value of `r mass/2.3` by 2.3 to give a new value of
> > `r mass` to the variable mass.
> >
> > ```{r ch2pt4-sol, class.source = 'fold-hide'}
> > age <- age - 20
> > ```
> > This will subtract 20 from the existing value of `r age + 20 ` to give a new value
> > of `r age` to the variable age.


> ### Challenge 3
>
> Run the code from the previous challenge, and write a command to
> compare mass to age. Is mass larger than age?
>
> > #### Solution to challenge 3
> >
> > One way of answering this question in R is to use the `>` to set up the following:
> > ```{r ch3-sol, class.source = 'fold-hide'}
> > mass > age
> >```
> > This should yield a boolean value of TRUE since `r mass` is greater than `r age`.


> ### Challenge 4
>
> Clean up your working environment by deleting the mass and age
> variables.
>
> > #### Solution to challenge 4
> >
> > We can use the `rm` command to accomplish this task
> > ```{r ch4-sol, class.source = 'fold-hide'}
> > rm(age, mass)
> > ```


> ### Challenge 5
>
> Install the following packages: `ggplot2`, `plyr`, `gapminder`
>
> > #### Solution to challenge 5
> >
> > We can use the `install.packages()` command to install the required packages.
> > ```{r ch5-sol, eval=FALSE, class.source = 'fold-hide'}
> > install.packages("ggplot2")
> > install.packages("plyr")
> > install.packages("gapminder")
> >```


# Seeking Help

## Reading Help files

R, and every package, provide help files for functions. The general syntax to search for help on any
function, "function_name", from a specific function that is in a package loaded into your
namespace (your interactive R session):

```{r, eval=FALSE}
?function_name
help(function_name)
```

This will load up a help page in RStudio (or as plain text in R by itself).

Each help page is broken down into sections:

 - Description: An extended description of what the function does.
 - Usage: The arguments of the function and their default values.
 - Arguments: An explanation of the data each argument is expecting.
 - Details: Any important details to be aware of.
 - Value: The data the function returns.
 - See Also: Any related functions you might find useful.
 - Examples: Some examples for how to use the function.

Different functions might have different sections, but these are the main ones you should be aware of.

> ### Tip: Reading help files
>
> One of the most daunting aspects of R is the large number of functions
> available. It would be prohibitive, if not impossible to remember the
> correct usage for every function you use. Luckily, the help files
> mean you don't have to!


## Special Operators

To seek help on special operators, use quotes:

```{r, eval=FALSE}
?"<-"
```

## Getting help on packages

Many packages come with "vignettes": tutorials and extended example documentation.
Without any arguments, `vignette()` will list all vignettes for all installed packages;
`vignette(package="package-name")` will list all available vignettes for
`package-name`, and `vignette("vignette-name")` will open the specified vignette.

If a package doesn't have any vignettes, you can usually find help by typing
`help("package-name")`.

## When you kind of remember the function

If you're not sure what package a function is in, or how it's specifically spelled you can do a fuzzy search:

```{r, eval=FALSE}
??function_name
```

## When you have no idea where to begin

If you don't know what function or package you need to use
[CRAN Task Views](http://cran.at.r-project.org/web/views)
is a specially maintained list of packages grouped into
fields. This can be a good starting point.

## When your code doesn't work: seeking help from your peers

If you're having trouble using a function, 9 times out of 10,
the answers you are seeking have already been answered on
[Stack Overflow](http://stackoverflow.com/). You can search using
the `[r]` tag.

If you can't find the answer, there are a few useful functions to
help you ask a question from your peers:

```{r, eval=FALSE}
?dput
```

Will dump the data you're working with into a format so that it can
be copy and pasted by anyone else into their R session.

```{r}
sessionInfo()
```

Will print out your current version of R, as well as any packages you
have loaded. This can be useful for others to help reproduce and debug
your issue.

> ### Challenge 1
>
> Look at the help for the `c` function. What kind of vector do you
> expect you will create if you evaluate the following:
> ```{r, eval=FALSE}
> c(1, 2, 3)
> c('d', 'e', 'f')
> c(1, 2, 'f')
> ```
> > #### Solution to Challenge 1
> >
> > The `c()` function creates a vector, in which all elements are the
> > same type. In the first case, the elements are numeric, in the
> > second, they are characters, and in the third they are characters:
> > the numeric values are "coerced" to be characters.


> ### Challenge 2
>
> Look at the help for the `paste` function. You'll need to use this later.
> What is the difference between the `sep` and `collapse` arguments?
>
> > #### Solution to Challenge 2
> >
> > To look at the help for the `paste()` function, use:
> > ```{r, eval=FALSE, class.source = 'fold-hide'}
> > help("paste")
> > ?paste
> > ```
> > The difference between `sep` and `collapse` is a little
> > tricky. The `paste` function accepts any number of arguments, each of which
> > can be a vector of any length. The `sep` argument specifies the string
> > used between concatenated terms — by default, a space. The result is a
> > vector as long as the longest argument supplied to `paste`. In contrast,
> > `collapse` specifies that after concatenation the elements are *collapsed*
> > together using the given separator, the result being a single string.
> > e.g. 
> > ```{r} 
> > paste(c("a","b"), "c")
> > paste(c("a","b"), "c", sep = ",")
> > paste(c("a","b"), "c", collapse = "|")
> > paste(c("a","b"), "c", sep = ",", collapse = "|")
> > ```
> > (For more information,
> > scroll to the bottom of the `?paste` help page and look at the
> > examples, or try `example('paste')`.)


> ### Challenge 3
> Use help to find a function (and its associated parameters) that you could
> use to load data from a csv file in which columns are delimited with "\t"
> (tab) and the decimal point is a "." (period). This check for decimal
> separator is important, especially if you are working with international
> colleagues, because different countries have different conventions for the
> decimal point (i.e. comma vs period).
>
> hint: use `??csv` to lookup csv related functions.
>
> > #### Solution to Challenge 3
> >
> > The standard R function for reading tab-delimited files with a period
> > decimal separator is read.delim(). You can also do this with
> > `read.table(file, sep="\t")` (the period is the *default* decimal
> > separator for `read.table()`, although you may have to change
> > the `comment.char` argument as well if your data file contains
> > hash (#) characters


## Other ports of call

* [Quick R](http://www.statmethods.net/)
* [RStudio cheat sheets](http://www.rstudio.com/resources/cheatsheets/)
* [Cookbook for R](http://www.cookbook-r.com/)


# Data Structures

```{r, echo=FALSE}
# Define variable containing url
url <- "https://devopedia.org/images/article/46/9213.1526125966.png"
```

<center><img src="`r url`"></center>
*photo credit: https://devopedia.org/r-data-structures*

```{r, echo=FALSE}
# Define variable containing url
url <- "https://devopedia.org/images/article/46/7262.1526126010.png"
```

<center><img src="`r url`"></center>
*images credits: https://devopedia.org/r-data-structures*

## Vector
A vector in R is essentially an ordered list of things, with the special condition that *everything in the vector must be the same basic data type*. If
you don't choose the datatype, it'll default to `logical`; or, you can declare an empty vector of whatever type you like.


The c() function creates a vector, in which all elements are the same type. In the first case, the elements are numeric, in the second, they are characters, and in the third they are characters: the numeric values are “coerced” to be characters.

### vector operator

```{r}
my_vector <- vector(length = 3)
my_vector
```

```{r}
another_vector <- vector(mode='character', length=3)
another_vector
```


### concatenate command c()
We can also make vectors with explicit contents with the combine function:

```{r concatenate}
c("a","b","c")
c(1,2,3)
```

Given what we've learned so far, what do you think the following will produce?

```{r}
quiz_vector <- c(2,6,'3')
```

This is something called *type coercion*, and it is the source of many surprises
and the reason why we need to be aware of the basic data types and how R will
interpret them. When R encounters a mix of types (here numeric and character) to
be combined into a single vector, it will force them all to be the same
type. Consider:

```{r}
coercion_vector <- c('a', TRUE)
coercion_vector
another_coercion_vector <- c(0, TRUE)
another_coercion_vector
```

The coercion rules go: `logical` -> `integer` -> `numeric` -> `complex` ->
`character`, where -> can be read as *are transformed into*. You can try to
force coercion against this flow using the `as.` functions:

```{r}
character_vector_example <- c('0','2','4')
character_vector_example
character_coerced_to_numeric <- as.numeric(character_vector_example)
character_coerced_to_numeric
numeric_coerced_to_logical <- as.logical(character_coerced_to_numeric)
numeric_coerced_to_logical
```

As you can see, some surprising things can happen when R forces one basic data
type into another! Nitty-gritty of type coercion aside, the point is: if your
data doesn't look like what you thought it was going to look like, type coercion
may well be to blame; make sure everything is the same type in your vectors and
your columns of data.frames, or you will get nasty surprises!

The combine function, `c()`, will also append things to an existing vector:

```{r}
ab_vector <- c('a', 'b')
ab_vector
combine_example <- c(ab_vector, 'SWC')
combine_example
```

You can also make series of numbers:

```{r}
mySeries <- 1:10
mySeries
seq(10)
seq(1,10, by=0.1)
```

We can ask a few questions about vectors:

```{r}
sequence_example <- seq(10)
head(sequence_example, n=2)
tail(sequence_example, n=4)
length(sequence_example)
class(sequence_example)
typeof(sequence_example)
```

Finally, you can give names to elements in your vector:

```{r}
my_example <- 5:8
names(my_example) <- c("a", "b", "c", "d")
my_example
names(my_example)
```

###  Vectors Subsetting
R has many powerful subset operators. Mastering them will allow you to
easily perform complex operations on any kind of dataset.

There are six different ways we can subset any kind of object, and three
different subsetting operators for the different data structures.

Let's start with the workhorse of R: a simple numeric vector.

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
x
```

> ### Atomic vectors
>
> In R, simple vectors containing character strings, numbers, or logical values are called *atomic* vectors because they can't be further simplified.


So now that we've created a dummy vector to play with, how do we get at its
contents?

### Accessing elements using their indices

To extract elements of a vector we can give their corresponding index, starting
from one:

```{r}
x[1]
```

```{r}
x[4]
```

It may look different, but the square brackets operator is a function. For vectors
(and matrices), it means "get me the nth element".

We can ask for multiple elements at once:

```{r}
x[c(1, 3)]
```

Or slices of the vector:

```{r}
x[1:4]
```

the `:` operator creates a sequence of numbers from the left element to the right.
```{r}
1:4
c(1, 2, 3, 4)
```


We can ask for the same element multiple times:

```{r}
x[c(1,1,3)]
```

If we ask for an index beyond the length of the vector, R will return a missing value:
```{r}
x[6]
```

This is a vector of length one containing an `NA`, whose name is also `NA`.

If we ask for the 0th element, we get an empty vector:

```{r}
x[0]
```

> ### Vector numbering in R starts at 1
>
> In many programming languages (C and Python, for example), the first
> element of a vector has an index of 0. In R, the first element is 1.


### Skipping and removing elements

If we use a negative number as the index of a vector, R will return
every element *except* for the one specified:

```{r}
x[-2]
```

We can skip multiple elements:

```{r}
x[c(-1, -5)]  # or x[-c(1,5)]
```

> ### Tip: Order of operations
>
> A common trip up for novices occurs when trying to skip
> slices of a vector. It's natural to try to negate a
> sequence like so:
>
> ```{r, error=TRUE, eval=FALSE}
> x[-1:3]
> ```
>
> This gives a somewhat cryptic error:
>
> ```{r, error=TRUE, echo=FALSE}
> x[-1:3]
> ```
>
> But remember the order of operations. `:` is really a function.
> It takes its first argument as -1, and its second as 3,
> so generates the sequence of numbers: `c(-1, 0, 1, 2, 3)`.
>
> The correct solution is to wrap that function call in brackets, so
> that the `-` operator applies to the result:
>
> ```{r}
> x[-(1:3)]
> ```



To remove elements from a vector, we need to assign the result back
into the variable:

```{r}
x <- x[-4]
x
```

> ### Challenge 1
>
> Given the following code:
>
> ```{r}
> x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
> names(x) <- c('a', 'b', 'c', 'd', 'e')
> print(x)
> ```
>
> Come up with at least 2 different commands that will produce the following output:
>
> ```{r, echo=FALSE}
> x[2:4]
> ```
>
> After you find 2 different commands, compare notes with your neighbour. Did you have different strategies?
>
> > #### Solution to challenge 1
> >
> > ```{r, class.source = 'fold-hide'}
> > x[2:4]
> > ```
> > ```{r, class.source = 'fold-hide'}
> > x[-c(1,5)]
> > ```
> > ```{r, class.source = 'fold-hide'}
> > x[c(2,3,4)]
> > ```
> >


### Subsetting by name

We can extract elements by using their name, instead of extracting by index:

```{r}
x <- c(a=5.4, b=6.2, c=7.1, d=4.8, e=7.5) # we can name a vector 'on the fly'
x[c("a", "c")]
```

This is usually a much more reliable way to subset objects: the
position of various elements can often change when chaining together
subsetting operations, but the names will always remain the same!

### Subsetting through other logical operations

We can also use any logical vector to subset:

```{r}
x[c(FALSE, FALSE, TRUE, FALSE, TRUE)]
```

Since comparison operators (e.g. `>`, `<`, `==`) evaluate to logical vectors, we can also
use them to succinctly subset vectors: the following statement gives
the same result as the previous one.

```{r}
x[x > 7]
```

Breaking it down, this statement first evaluates `x>7`, generating
a logical vector `c(FALSE, FALSE, TRUE, FALSE, TRUE)`, and then
selects the elements of `x` corresponding to the `TRUE` values.

We can use `==` to mimic the previous method of indexing by name
(remember you have to use `==` rather than `=` for comparisons):

```{r}
x[names(x) == "a"]
```


## Data Frames
Data frames are the _de facto_ data structure for most tabular data, and what we
use for statistics and plotting.

A data frame can be created by hand, but most commonly they are generated by the
functions `read.csv()` or `read.table()`; in other words, when importing
spreadsheets from your hard drive (or the web).

A data frame is the representation of data in the format of a table where the
columns are vectors that all have the same length. Because columns are
vectors, each column must contain a single type of data (e.g., characters, integers,
factors). For example, here is a figure depicting a data frame comprising a
numeric, a character, and a logical vector.

![](./fig/download.svg)

We can see this when inspecting the <b>str</b>ucture of a data frame
with the function `str()`:



You are now ready to load the data:

```{r, eval=TRUE,  purl=FALSE}
taxonomic_profiles <- data.frame(taxonomy = c("Otu00001", "Otu00002", "Otu00003", "Otu00004", "Otu00005", "Otu00006", "Otu00007"), 
                    Sample1 = c(21, 50, 32, 20, 10, 66, 100), 
                    Sample2 = c(31, 40, 10, 20, 46, 89, 23),
                    Sample3 = c(22, 100, 10, 55, 65, 93 ,56))
write.csv(x = taxonomic_profiles, file = "data/taxonomic_profiles.csv", row.names = FALSE)
```

```{r, purl=FALSE}
str(taxonomic_profiles)
```

### Inspecting `data.frame` Objects

We already saw how the functions `head()` and `str()` can be useful to check the
content and the structure of a data frame. Here is a non-exhaustive list of
functions to get a sense of the content/structure of the data. Let's try them out!

* Size:
    * `dim(taxonomic_profiles)` - returns a vector with the number of rows in the first element,
          and the number of columns as the second element (the **dim**ensions of
          the object)
    * `nrow(taxonomic_profiles)` - returns the number of rows
    * `ncol(taxonomic_profiles)` - returns the number of columns

* Content:
    * `head(taxonomic_profiles)` - shows the first 6 rows
    * `tail(taxonomic_profiles)` - shows the last 6 rows

* Names:
    * `names(taxonomic_profiles)` - returns the column names (synonym of `colnames()` for `data.frame`
	   objects)
    * `rownames(taxonomic_profiles)` - returns the row names

* Summary:
    * `str(taxonomic_profiles)` - structure of the object and information about the class, length and
	   content of  each column
    * `summary(taxonomic_profiles)` - summary statistics for each column

Note: most of these functions are "generic", they can be used on other types of
objects besides `data.frame`.

> ### Challenge
>
> Based on the output of `str(taxonomic_profiles)`, can you answer the following questions?
>
> * What is the class of the object `taxonomic_profiles`?
> * How many rows and how many columns are in this object?
>
> ```{r, answer=TRUE, results="markup", purl=FALSE}
>
> str(taxonomic_profiles)
>
> ## * class: data frame
> ## * how many rows: 7,  how many columns: 4

> ```


```{r, echo=FALSE, purl=TRUE}

## Challenge
## Based on the output of `str(taxonomic_profiles)`, can you answer the following questions?
## * What is the class of the object `taxonomic_profiles`?
## * How many rows and how many columns are in this object?
## * How many species have been recorded during these taxonomic_profiles?

```



### Indexing and subsetting data frames

```{r, echo=FALSE, purl=TRUE}

## Indexing and subsetting data frames
```


Our survey data frame has rows and columns (it has 2 dimensions), if we want to
extract some specific data from it, we need to specify the "coordinates" we
want from it. Row numbers come first, followed by column numbers. However, note
that different ways of specifying these coordinates lead to results with
different classes.


```{r, purl=FALSE}
# first element in the first column of the data frame (as a vector)
taxonomic_profiles[1, 1]   
# first element in the 6th column (as a vector)
taxonomic_profiles[1, 6]   
# first column of the data frame (as a vector)
taxonomic_profiles[, 1]    
# first column of the data frame (as a data.frame)
taxonomic_profiles[1]      
# first three elements in the 5th column (as a vector)
taxonomic_profiles[1:3, 5] 
# the 3rd row of the data frame (as a data.frame)
taxonomic_profiles[3, ]    
# equivalent to head_taxonomic_profiles <- head(taxonomic_profiles)
head_taxonomic_profiles <- taxonomic_profiles[1:4, ] 
```

`:` is a special function that creates numeric vectors of integers in increasing
or decreasing order, test `1:10` and `10:1` for instance.

You can also exclude certain indices of a data frame using the "`-`" sign:

```{r, purl=FALSE}
taxonomic_profiles[, -1]          # The whole data frame, except the first column
taxonomic_profiles[-c(7:34786), ] # Equivalent to head(taxonomic_profiles)
```

Data frames can be subset by calling indices (as shown previously), but also by calling their column names directly:

```{r, eval = FALSE, purl=FALSE}
taxonomic_profiles["taxonomy"]       # Result is a data.frame
taxonomic_profiles[, "taxonomy"]     # Result is a vector
taxonomic_profiles[["taxonomy"]]     # Result is a vector
taxonomic_profiles$taxonomy          # Result is a vector
```

In RStudio, you can use the autocompletion feature to get the full and correct names of the columns.

> ### Challenge
>
> 1. Create a `data.frame` (`taxonomic_profiles_200`) containing only the data in
>    row 200 of the `taxonomic_profiles` dataset.
>
> 2. Notice how `nrow()` gave you the number of rows in a `data.frame`?
>
>      * Use that number to pull out just that last row in the data frame.
>      * Compare that with what you see as the last row using `tail()` to make
>        sure it's meeting expectations.
>      * Pull out that last row using `nrow()` instead of the row number.
>      * Create a new data frame (`taxonomic_profiles_last`) from that last row.
>
> 3. Use `nrow()` to extract the row that is in the middle of the data
>    frame. Store the content of this row in an object named `taxonomic_profiles_middle`.
>
> 4. Combine `nrow()` with the `-` notation above to reproduce the behavior of
>    `head(taxonomic_profiles)`, keeping just the first through 6th rows of the taxonomic_profiles
>    dataset.
>
> ```{r, answer=TRUE, purl=FALSE}
> ## 1.
> taxonomic_profiles_200 <- taxonomic_profiles[200, ]
> ## 2.
> # Saving `n_rows` to improve readability and reduce duplication
> n_rows <- nrow(taxonomic_profiles)
> taxonomic_profiles_last <- taxonomic_profiles[n_rows, ]
> ## 3.
> taxonomic_profiles_middle <- taxonomic_profiles[n_rows / 2, ]
> ## 4.
> taxonomic_profiles_head <- taxonomic_profiles[-(7:n_rows), ]
> ```


```{r, echo=FALSE, purl=TRUE}
### Challenges:
###
### 1. Create a `data.frame` (`taxonomic_profiles_200`) containing only the
###    data in row 200 of the `taxonomic_profiles` dataset.
###
### 2. Notice how `nrow()` gave you the number of rows in a `data.frame`?
###
###      * Use that number to pull out just that last row in the data frame
###      * Compare that with what you see as the last row using `tail()` to make
###        sure it's meeting expectations.
###      * Pull out that last row using `nrow()` instead of the row number
###      * Create a new data frame object (`taxonomic_profiles_last`) from that last row
###
### 3. Use `nrow()` to extract the row that is in the middle of the
###    data frame. Store the content of this row in an object named
###    `taxonomic_profiles_middle`.
###
### 4. Combine `nrow()` with the `-` notation above to reproduce the behavior of
###    `head(taxonomic_profiles)`, keeping just the first through 6th rows of the taxonomic_profiles
###    dataset.

```

We can load this into R via the following:

```{r}
raw_profiles <- read.csv(file = "data/raw_taxonomic_profiles.csv")
raw_profiles
```

The `read.table` function is used for reading in tabular data stored in a text
file where the columns of data are separated by punctuation characters such as
CSV files (csv = comma-separated values). Tabs and commas are the most common
punctuation characters used to separate or delimit data points in csv files. 
For convenience R provides 2 other versions of `read.table`. These are: `read.csv`
for files where the data are separated with commas and `read.delim` for files
where the data are separated with tabs. Of these three functions `read.csv` is
the most commonly used.  If needed it is possible to override the default 
delimiting punctuation marks for both `read.csv` and `read.delim`.


We can begin exploring our dataset right away, pulling out columns by specifying
them using the `$` operator:

```{r}
raw_profiles$vd1
raw_profiles$taxonomy
```

We can do other operations on the columns:

```{r}
## Say we discovered that the scale weighs two Kg light:
raw_profiles$vd1 + 2
paste("My OTU is", raw_profiles$taxonomy)
```

But what about

```{r}
raw_profiles$vd1 + raw_profiles$taxonomy
```

Understanding what happened here is key to successfully analyzing data in R.

### Data Types

If you guessed that the last command will return an error because `2.1` plus
`"black"` is nonsense, you're right - and you already have some intuition for an
important concept in programming called *data types*. We can ask what type of
data something is:

```{r}
typeof(raw_profiles$vd1)
```

There are 5 main types: `double`, `integer`, `complex`, `logical` and `character`.

```{r}
typeof(3.14)
typeof(1L) # The L suffix forces the number to be an integer, since by default R uses float numbers
typeof(1+1i)
typeof(TRUE)
typeof('banana')
```

No matter how
complicated our analyses become, all data in R is interpreted as one of these
basic data types. This strictness has some really important consequences.


```{r, eval=FALSE}
file.show("data/raw_taxonomic_profiles.csv")
```

```{r, eval=FALSE}
"taxonomy","vd1","vd2"
"Otu00001",2.1,1
"Otu00002",5,0
"Otu00003",3.2,1

```

Load the new raw_profiles data like before, and check what type of data we find in the
`taxonomy` column:

```{r}
raw_profiles <- read.csv(file="data/raw_taxonomic_profiles.csv")
typeof(raw_profiles$taxonomy)
```

Oh no, our vd1 aren't the double type anymore! If we try to do the same math
we did on them before, we run into trouble:

```{r}
raw_profiles$vd1 + 2
```

What happened? When R reads a csv file into one of these tables, it insists that
everything in a column be the same basic type; if it can't understand
*everything* in the column as a double, then *nobody* in the column gets to be a
double. The table that R loaded our raw_profiles data into is something called a
*data.frame*, and it is our first example of something called a *data
structure* - that is, a structure which R knows how to build out of the basic
data types.

We can see that it is a *data.frame* by calling the `taxonomy` function on it:

```{r}
class(raw_profiles)
```



## Factors

```{r, echo=FALSE, purl=TRUE}
### Factors
```

When we did `str(taxonomic_profiles)` we saw that several of the columns consist of
integers. The columns `taxonomy`, ... however, are
of a special class called `factor`. Factors are very useful and actually
contribute to making R particularly well suited to working with data. So we are
going to spend a little time introducing them.

Factors represent categorical data. They are stored as integers associated with labels and they can be ordered or unordered. While factors look (and often behave) like character vectors, they are actually treated as integer vectors by R. So you need to be very careful when treating them as strings.

Once created, factors can only contain a pre-defined set of values, known as
*levels*. By default, R always sorts levels in alphabetical order. For
instance, if you have a factor with 2 levels:

```{r, purl=TRUE}
sex <- factor(c("male", "female", "female", "male"))
```

R will assign `1` to the level `"female"` and `2` to the level `"male"` (because
`f` comes before `m`, even though the first element in this vector is
`"male"`). You can see this by using the function `levels()` and you can find the
number of levels using `nlevels()`:

```{r, purl=FALSE}
levels(sex)
nlevels(sex)
```

Sometimes, the order of the factors does not matter, other times you might want
to specify the order because it is meaningful (e.g., "low", "medium", "high"),
it improves your visualization, or it is required by a particular type of
analysis. Here, one way to reorder our levels in the `sex` vector would be:

```{r, results=TRUE, purl=FALSE}
sex # current order
sex <- factor(sex, levels = c("male", "female"))
sex # after re-ordering
```

In R's memory, these factors are represented by integers (1, 2, 3), but are more
informative than integers because factors are self describing: `"female"`,
`"male"` is more descriptive than `1`, `2`. Which one is "male"?  You wouldn't
be able to tell just from the integer data. Factors, on the other hand, have
this information built in. It is particularly helpful when there are many levels
(like the species names in our example dataset).

### Factor subsetting

Now that we've explored the different ways to subset vectors, how
do we subset the other data structures?

Factor subsetting works the same way as vector subsetting.

```{r}
f <- factor(c("a", "a", "b", "c", "c", "d"))
f[f == "a"]
f[f %in% c("b", "c")]
f[1:3]
```

Skipping elements will not remove the level
even if no more of that category exists in the factor:

```{r}
f[-3]
```


## Lists

Another data structure you'll want in your bag of tricks is the `list`. A list
is simpler in some ways than the other types, because you can put anything you
want in it:

```{r}
list_example <- list(1, "a", TRUE, 1+4i)
list_example
another_list <- list(title = "Numbers", numbers = 1:10, data = TRUE )
another_list
```

We can now understand something a bit surprising in our data.frame; what happens if we run:

```{r}
typeof(raw_profiles)
```

We see that data.frames look like lists 'under the hood' - this is because a
data.frame is really a list of vectors and factors, as they have to be - in
order to hold those columns that are a mix of vectors and factors, the
data.frame needs something a bit more flexible than a vector to put all the
columns together into a familiar table.  In other words, a `data.frame` is a
special list in which all the vectors must have the same length.

In our example, we have an integer, a double and a logical variable. As
we have seen already, each column of data.frame is a vector.

```{r}
raw_profiles$taxonomy
raw_profiles[,1]
typeof(raw_profiles[,1])
str(raw_profiles[,1])
```

Each row is an *observation* of different variables, itself a data.frame, and
thus can be composed of elements of different types.

```{r}
raw_profiles[1,]
typeof(raw_profiles[1,])
str(raw_profiles[1,])
```

> ### Challenge 3
>
> There are several subtly different ways to call variables, observations and
> elements from data.frames:
>
> - `raw_profiles[1]`
> - `raw_profiles[[1]]`
> - `raw_profiles$coat`
> - `raw_profiles["coat"]`
> - `raw_profiles[1, 1]`
> - `raw_profiles[, 1]`
> - `raw_profiles[1, ]`
>
> Try out these examples and explain what is returned by each one.
>
> *Hint:* Use the function `typeof()` to examine what is returned in each case.
>
> > #### Solution to Challenge 3
> > ```{r, eval=TRUE, echo=TRUE, class.source = 'fold-hide'}
> > raw_profiles[1]
> > ```
> > We can think of a data frame as a list of vectors. The single brace `[1]`
> returns the first slice of the list, as another list. In this case it is the
> first column of the data frame.
> > ```{r, eval=TRUE, echo=TRUE, class.source = 'fold-hide'}
> > raw_profiles[[1]]
> > ```
> > The double brace `[[1]]` returns the contents of the list item. In this case
> it is the contents of the first column, a _vector_ of type _factor_.
> > ```{r, eval=TRUE, echo=TRUE, class.source = 'fold-hide'}
> > raw_profiles$taxonomy
> > ```

> > ```
> > Here we are using a single brace `["taxonomy"]` replacing the index number with
> the column name. Like example 1, the returned object is a _list_.
> > ```{r, eval=TRUE, echo=TRUE, class.source = 'fold-hide'}
> > raw_profiles[1, 1]
> > ```
> > This example uses a single brace, but this time we provide row and column
> coordinates. The returned object is the value in row 1, column 1. The object
> is an _integer_ but because it is part of a _vector_ of type _factor_, R
> displays the label "calico" associated with the integer value.
> > ```{r, eval=TRUE, echo=TRUE, class.source = 'fold-hide'}
> > raw_profiles[, 1]
> > ```
> > Like the previous example we use single braces and provide row and column
> coordinates. The row coordinate is not specified, R interprets this missing
> value as all the elements in this _column_ _vector_.
> > ```{r, eval=TRUE, echo=TRUE, class.source = 'fold-hide'}
> > raw_profiles[1, ]
> > ```
> > Again we use the single brace with row and column coordinates. The column
> coordinate is not specified. The return value is a _list_ containing all the
> values in the first row.


### List subsetting

Now we'll introduce some new subsetting operators. There are three functions
used to subset lists. We've already seen these when learning about atomic vectors and matrices:  `[`, `[[`, and `$`.

Using `[` will always return a list. If you want to *subset* a list, but not
*extract* an element, then you will likely use `[`.

```{r}
xlist <- list(a = "Software Carpentry", b = 1:10, data = head(iris))
xlist[1]
```

This returns a *list with one element*.

We can subset elements of a list exactly the same way as atomic
vectors using `[`. Comparison operations however won't work as
they're not recursive, they will try to condition on the data structures
in each element of the list, not the individual elements within those
data structures.

```{r}
xlist[1:2]
```

To extract individual elements of a list, you need to use the double-square
bracket function: `[[`.

```{r}
xlist[[1]]
```

Notice that now the result is a vector, not a list.

You can't extract more than one element at once:

```{r, error=TRUE}
xlist[[1:2]]
```

Nor use it to skip elements:

```{r, error=TRUE}
xlist[[-1]]
```

But you can use names to both subset and extract elements:

```{r}
xlist[["a"]]
```

The `$` function is a shorthand way for extracting elements by name:

```{r}
xlist$data
```

> ### Challenge 5
> Given the following list:
>
> ```{r, eval=FALSE}
> xlist <- list(a = "Software Carpentry", b = 1:10, data = head(iris))
> ```
>
> Using your knowledge of both list and vector subsetting, extract the number 2 from xlist.
> Hint: the number 2 is contained within the "b" item in the list.
>
> > #### Solution to challenge 5
> >
> > ```{r, class.source = 'fold-hide'}
> > xlist$b[2]
> > ```
> > ```{r, class.source = 'fold-hide'}
> > xlist[[2]][2]
> > ```
> > ```{r, class.source = 'fold-hide'}
> > xlist[["b"]][2]
> > ```



## Matrices

Last but not least is the matrix. We can declare a matrix full of zeros:

```{r}
matrix_example <- matrix(0, ncol=6, nrow=3)
matrix_example
```

And similar to other data structures, we can ask things about our matrix:

```{r}
class(matrix_example)
typeof(matrix_example)
str(matrix_example)
dim(matrix_example)
nrow(matrix_example)
ncol(matrix_example)
```

> ### Challenge 4
>
> What do you think will be the result of
> `length(matrix_example)`?
> Try it.
> Were you right? Why / why not?
>
> > #### Solution to Challenge 4
> >
> > What do you think will be the result of
> > `length(matrix_example)`?
> >
> > ```{r, class.source = 'fold-hide'}
> > matrix_example <- matrix(0, ncol=6, nrow=3)
> > length(matrix_example)
> > ```
> >
> > Because a matrix is a vector with added dimension attributes, `length`
> > gives you the total number of elements in the matrix.


> ### Challenge 5
>
> Make another matrix, this time containing the numbers 1:50,
> with 5 columns and 10 rows.
> Did the `matrix` function fill your matrix by column, or by
> row, as its default behaviour?
> See if you can figure out how to change this.
> (hint: read the documentation for `matrix`!)
>
> > #### Solution to Challenge 5
> >
> > Make another matrix, this time containing the numbers 1:50,
> > with 5 columns and 10 rows.
> > Did the `matrix` function fill your matrix by column, or by
> > row, as its default behaviour?
> > See if you can figure out how to change this.
> > (hint: read the documentation for `matrix`!)
> >
> > ```{r, eval=FALSE, class.source = 'fold-hide'}
> > x <- matrix(1:50, ncol=5, nrow=10)
> > x <- matrix(1:50, ncol=5, nrow=10, byrow = TRUE) # to fill by row
> > ```



> ### Challenge 6
>  Create a list of length two containing a character vector for each of the sections in this part of the workshop:
>
>  - Data types
>  - Data structures
>
>  Populate each character vector with the names of the data types and data
>  structures we've seen so far.
>
> > #### Solution to Challenge 6
> > ```{r, class.source = 'fold-hide'}
> > dataTypes <- c('double', 'complex', 'integer', 'character', 'logical')
> > dataStructures <- c('data.frame', 'vector', 'factor', 'list', 'matrix')
> > answer <- list(dataTypes, dataStructures)
> > ```
> > Note: it's nice to make a list in big writing on the board or taped to the wall
> > listing all of these types and structures - leave it up for the rest of the workshop
> > to remind people of the importance of these basics.
> >


> ### Challenge 7
>
> Consider the R output of the matrix below:
> ```{r, echo=FALSE}
> matrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)
> ```
> What was the correct command used to write this matrix? Examine
> each command and try to figure out the correct one before typing them.
> Think about what matrices the other commands will produce.
>
> 1. `matrix(c(4, 1, 9, 5, 10, 7), nrow = 3)`
> 2. `matrix(c(4, 9, 10, 1, 5, 7), ncol = 2, byrow = TRUE)`
> 3. `matrix(c(4, 9, 10, 1, 5, 7), nrow = 2)`
> 4. `matrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)`
>
> > #### Solution to Challenge 7
> >
> > Consider the R output of the matrix below:
> > ```{r, echo=FALSE, class.source = 'fold-hide'}
> > matrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)
> > ```
> > What was the correct command used to write this matrix? Examine
> > each command and try to figure out the correct one before typing them.
> > Think about what matrices the other commands will produce.
> > ```{r, eval=FALSE}
> > matrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)
> > ```


### Matrix subsetting

Matrices are also subsetted using the `[` function. In this case
it takes two arguments: the first applying to the rows, the second
to its columns:

```{r}
set.seed(1)
m <- matrix(rnorm(6*4), ncol=4, nrow=6)
m[3:4, c(3,1)]
```

You can leave the first or second arguments blank to retrieve all the
rows or columns respectively:

```{r}
m[, c(3,4)]
```

If we only access one row or column, R will automatically convert the result
to a vector:

```{r}
m[3,]
```

If you want to keep the output as a matrix, you need to specify a *third* argument;
`drop = FALSE`:

```{r}
m[3, , drop=FALSE]
```

Unlike vectors, if we try to access a row or column outside of the matrix,
R will throw an error:

```{r, error=TRUE}
m[, c(3,6)]
```

> ### Tip: Higher dimensional arrays
>
> when dealing with multi-dimensional arrays, each argument to `[`
> corresponds to a dimension. For example, a 3D array, the first three
> arguments correspond to the rows, columns, and depth dimension.
>


Because matrices are vectors, we can
also subset using only one argument:

```{r}
m[5]
```


This usually isn't useful, and often confusing to read. However it is useful to note that matrices
are laid out in *column-major format* by default. That is the elements of the
vector are arranged column-wise:

```{r}
matrix(1:6, nrow=2, ncol=3)
```

If you wish to populate the matrix by row, use `byrow=TRUE`:

```{r}
matrix(1:6, nrow=2, ncol=3, byrow=TRUE)
```

Matrices can also be subsetted using their rownames and column names
instead of their row and column indices.

> ### Challenge 4
>
> Given the following code:
>
> ```{r}
> m <- matrix(1:18, nrow=3, ncol=6)
> print(m)
> ```
>
> 1. Which of the following commands will extract the values 11 and 14?
>
> A. `m[2,4,2,5]`
>
> B. `m[2:5]`
>
> C. `m[4:5,2]`
>
> D. `m[2,c(4,5)]`
>
> > #### Solution to challenge 4
> >
> > D


# Control Flow

Often when we're coding we want to control the flow of our actions. This can be done
by setting actions to occur only if a condition or a set of conditions are met.
Alternatively, we can also set an action to occur a particular number of times.

There are several ways you can control flow in R.
For conditional statements, the most commonly used approaches are the constructs:

```{r, eval=FALSE}
# if
if (condition is true) {
  perform action
}

# if ... else
if (condition is true) {
  perform action
} else {  # that is, if the condition is false,
  perform alternative action
}
```

Say, for example, that we want R to print a message if a variable `x` has a particular value:

```{r}
x <- 8

if (x >= 10) {
  print("x is greater than or equal to 10")
}

x
```

The print statement does not appear in the console because x is not greater than 10. To print a different message for numbers less than 10, we can add an `else` statement.

```{r}
x <- 8

if (x >= 10) {
  print("x is greater than or equal to 10")
} else {
  print("x is less than 10")
}
```

You can also test multiple conditions by using `else if`.

```{r}
x <- 8

if (x >= 10) {
  print("x is greater than or equal to 10")
} else if (x > 5) {
  print("x is greater than 5, but less than 10")
} else {
  print("x is less than 5")
}
```

**Important:** when R evaluates the condition inside `if()` statements, it is
looking for a logical element, i.e., `TRUE` or `FALSE`. This can cause some
headaches for beginners. For example:

```{r}
x  <-  4 == 3
if (x) {
  "4 equals 3"
} else {
  "4 does not equal 3"          
}
```

As we can see, the not equal message was printed because the vector x is `FALSE`

```{r}
x <- 4 == 3
x
```



Did anyone get a warning message like this?

```{r, echo=FALSE}
if (raw_profiles$taxonomy == 2012) {}
```

If your condition evaluates to a vector with more than one logical element,
the function `if()` will still run, but will only evaluate the condition in the first
element. Here you need to make sure your condition is of length 1.

> ## Tip: `any()` and `all()`
>
> The `any()` function will return TRUE if at least one
> TRUE value is found within a vector, otherwise it will return `FALSE`.
> This can be used in a similar way to the `%in%` operator.
> The function `all()`, as the name suggests, will only return `TRUE` if all values in
> the vector are `TRUE`.


## Repeating operations

If you want to iterate over
a set of values, when the order of iteration is important, and perform the
same operation on each, a `for()` loop will do the job.
We saw `for()` loops in the shell lessons earlier. This is the most
flexible of looping operations, but therefore also the hardest to use
correctly. Avoid using `for()` loops unless the order of iteration is important:
i.e. the calculation at each iteration depends on the results of previous iterations.

The basic structure of a `for()` loop is:

```{r, eval=FALSE}
for(iterator in set of values){
  do a thing
}
```

For example:

```{r}
for(i in 1:10){
  print(i)
}
```

The `1:10` bit creates a vector on the fly; you can iterate
over any other vector as well.

We can use a `for()` loop nested within another `for()` loop to iterate over two things at
once.

```{r}
for(i in 1:5){
  for(j in c('a', 'b', 'c', 'd', 'e')){
    print(paste(i,j))
  }
}
```

Rather than printing the results, we could write the loop output to a new object.

```{r}
output_vector <- c()
for(i in 1:5){
  for(j in c('a', 'b', 'c', 'd', 'e')){
    temp_output <- paste(i, j)
    output_vector <- c(output_vector, temp_output)
  }
}
output_vector
```

# Data Frame Operators

## Adding columns and rows in data frames
### cbind
We already learned that the columns of a data frame are vectors, so that our data are consistent in type throughout the columns. As such, if we want to add a new column, we can start by making a new vector:
```{r}
vd3 <- c(61, 40, 32)
vd3
```

```{r}
cbind(raw_profiles, vd3)
```

### rbind
Now how about adding rows? We already know that the rows of a data frame are lists:

```{r}
newRow <- list("Otu00004", 3.3, 3, 90)
raw_profiles_new <- rbind(raw_profiles, newRow)
raw_profiles_new
```


### merge
```{r}
# merge two data frames by taxonomy
taxonomic_mapping <- read.csv(file = "data/taxonomic_mapping.csv")
taxonomic_mapping
taxonomic_profiles
merged_table <- merge(taxonomic_profiles,taxonomic_mapping,by="taxonomy")
```

# The dplyr package
Luckily, the dplyr package provides a number of very useful functions for manipulating dataframes in a way that will reduce the above repetition, reduce the probability of making errors, and probably even save you some typing. As an added bonus, you might even find the dplyr grammar easier to read.

Here we’re going to cover 6 of the most commonly used functions as well as using pipes (%>%) to combine them.

select() filter() group_by() summarize() mutate()

If you have have not installed this package earlier, please do so:
```{r eval=FALSE}
install.packages('dplyr')
```

Now let’s load the package
```{r}
library("dplyr")
```


## Using select()
If, for example, we wanted to move forward with only a few of the variables in our dataframe we could use the select() function. This will keep only the variables you select.
```{r}
table_kingdom_phylum <- select(merged_table,taxonomy,Sample1,Kingdom, Phylum)
```

## using pipes
```{r}
table_select <- merged_table %>% 
                          select(taxonomy,Sample1,Kingdom, Phylum)
```

## Using filter()
we can combine select and filter
```{r}
table_select <- merged_table %>% 
                          filter(Kingdom=='Bacteria')
table_select
```

## Using Select and filter
```{r}
table_select_filter <- merged_table %>% 
                          filter(Kingdom=='Bacteria') %>%
                          select(taxonomy, Sample1)
```

## Using summarize()
The above was a bit on the uneventful side but group_by() is much more exciting in conjunction with summarize(). This will allow us to create new variable(s) by using functions that repeat for each of the continent-specific data frames. That is to say, using the group_by() function, we split our original dataframe into multiple pieces, then we can run functions (e.g. mean() or sd()) within summarize().
```{r}
otu_groupby_phylum <- merged_table %>%
    group_by(Phylum) %>%
    summarize(mean_sample1=mean(Sample1))
otu_groupby_phylum
```

# The ggplot package

Install ggplot
```{r eval=FALSE}
install.packages("ggplot2")
```
Plot a simple figure
```{r}
library(ggplot2)
ggplot(data = merged_table, aes(y = Sample3, x = taxonomy, by=Genus, color=Family)) + geom_point()
```


# Resources for Learning R
 - Cheatsheets: https://rstudio.com/resources/cheatsheets/
 - swirl: http://swirlstats.com/
 - Quick-R: https://www.statmethods.net/
 - Software Carpentry
 - R for Reproducible Scientific Analysis: http://swcarpentry.github.io/r-novice-gapminder/
 - Programming with R: http://swcarpentry.github.io/r-novice-inflammation/
 - Cookbook for R: http://www.cookbook-r.com/
 - R for Data Science: http://r4ds.had.co.nz/
 - R Data Structures: https://image.slidesharecdn.com/lsesudsrworkshopcomplete-170124103937/95/lsesu-a-taste-of-r-language-workshop-33-638.jpg?cb=1485365496
 - Publication quality graphics with R: boxplots, time series, scatterplots: https://smcclatchy.github.io/r-pub-quality-graphics/
 - Data Structures: http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png
 - Link to Hadley Wickham's Tidy Data paper: http://vita.had.co.nz/papers/tidy-data.html
 - Learn Regular expressions: http://web.mit.edu/hackl/www/lab/turkshop/slides/regex-cheatsheet.pdf
 - Markdown: https://rmarkdown.rstudio.com/gallery.html; http://timelyportfolio.github.io/rCharts_nyt_home_price/
 - Writing R packages for organizing analyses for those with a few weeks/months of R experience: http://r-pkgs.had.co.nz/
 - Recommended general project structure and other good scientific computing practices: https://arxiv.org/abs/1609.00037
 - For workflows and best practices for analysis in R, Bioconductor: https://bioconductor.org/
 - dplyr: https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf

# Copyright
> Copyright: Materials used in these lessons were derived from work that is Copyright © Data Carpentry >(http://datacarpentry.org/). All Data Carpentry instructional material is made available under the Creative >Commons Attribution license (CC BY 4.0). 

>Thomas Wright and Naupaka Zimmerman (eds): "Software Carpentry: R >forReproducible Scientific Analysis." Version 2016.06, June >2016,https://github.com/swcarpentry/r-novice-gapminder,10.5281/zenodo.57520.